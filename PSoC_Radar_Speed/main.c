/******************************************************************************
* Student's name: Huynh Le Nhat Tam
* FRA-UAS Matriculation Number: 1318526 
* Date: 11th May 2022
*******************************************************************************/

#include <project.h>
#include "stdio.h"
#include <VDAC8_1.h>

/* The clock frequency for the PWM_Window. The PWM_Window clock frequency must be in KHz. 
 * Please update this define if the clock is updated in the TopDesign */
#define PWM_FREQ 10 //This seems to be the clock frequency that produces the most stable measured frequencies

/* Define for 1 second in terms of millisecond */
#define NO_OF_MSEC 1000

uint8 compare_occured = 0;
char uartout[20];
char isrcall[20] = "ISR is called \r\n";

void DMA_1_Config(void);
void DMA_2_Config(void);

CY_ISR_PROTO(myCompareisr);

int main()
{
    uint32 input_freq = 0;	//input_freq stores the value of the Doppler frequency generated by the radar sensor
    uint32 speed = 0;
	/* Variable to store the Period of the PWM_Window */
	static uint16 PWM_windowPeriod = 0;
	/* Variable to store the count value after capture */
	 static uint32 counter_countVal;
    /* Start the components */
    UART_1_Start();
    Opamp_1_Start();
    Filter_1_Start();
    VDAC8_1_Start();
    ADC_SAR_1_Start();
    PWM_Window_Start();
	Counter_Start();
    Clock_PWM_Start(); //not necessary because the clocks automatically start
    Comp_1_Start();
    LCD_Start();
    /* Set up DMA (Direct Memory Access) */
    DMA_1_Config();
    DMA_2_Config();
    
    
    /* Start the ADC conversion */
    ADC_SAR_1_StartConvert();
    /* Send message to verify COM port is connected properly */
    UART_1_PutString("COM Port Open");
    /* Set the Power Mode of the op amp as HIGH POWER*/
    Opamp_1_SetPower(Opamp_1_HIGHPOWER);
	/* Calculate the time window during which the counter will count */
	PWM_windowPeriod = PWM_Window_ReadPeriod() ;
	/* Update the Time window value according to the clock given to the PWM_Window */
	PWM_windowPeriod = PWM_windowPeriod/ PWM_FREQ; 
    
    /* Enable the global interrupt */
	CYGlobalIntEnable;
    
    ISR_Compare_StartEx(myCompareisr);
    for(;;)
    {                
        /* Check to see if an ADC conversion has completed */
        if(ADC_SAR_1_IsEndConversion(ADC_SAR_1_RETURN_STATUS))
        {
            /* Check if the PWM interrupt has occurred
		 * The code works in such a way that, the PWM Compare event has an interrupt.
		 * The interrupt occurs for every second (Interrupt on Compare Event)
		 * The frequency calculation is done whenever the interrupt occurs */
		if (compare_occured == 1)
		{
			/* Read the Counter capture register */
			counter_countVal = Counter_ReadCapture();
			
			/* Convert the counts to frequency.
			 * Frequency is the number of counts in seconds
			 */
			input_freq = ((uint32)(NO_OF_MSEC * (uint32)counter_countVal) / (uint32)PWM_windowPeriod); 
            speed = input_freq/19.51; //Speed of light in air: 299 702 547 m/s = 1 078 929 169 km/h
            
            LCD_ClearDisplay(); //Clear the old displayed value
            LCD_Position(0, 0);
	        LCD_PrintString("Frequency:");	
            LCD_Position(0, 10);
			LCD_PrintU32Number(input_freq);
            LCD_Position(0, 14);
            LCD_PrintString("Hz");
			LCD_Position(1, 0);
            LCD_PrintString("Speed: ");
			LCD_PrintU32Number(speed); 
			LCD_Position(1, 12);
			LCD_PrintString("km/h");	            
            sprintf(uartout,"Frequency: %lu Hz, Speed: %lu km/h \r\n", input_freq, speed);
            UART_1_PutString(uartout);

			/* Clear the interrupt flag */
			compare_occured = 0;    
		}
        }
    }
}

CY_ISR(myCompareisr)
{
  /* START ISR_Compare_Interrupt */
compare_occured = 1; // Set the flag to indicate occurence of the interrupt
UART_1_PutString(isrcall);
PWM_Window_ReadStatusRegister(); // Call the ReadStatusRegister to clear the Interrupt Status bit 
}
void DMA_1_Config(void)
{
 /* Defines for DMA_1 */
#define DMA_1_BYTES_PER_BURST 2
#define DMA_1_REQUEST_PER_BURST 1
#define DMA_1_SRC_BASE (CYDEV_PERIPH_BASE)
#define DMA_1_DST_BASE (CYDEV_PERIPH_BASE)

/* Variable declarations for DMA_1 */
/* Move these variable declarations to the top of the function */
uint8 DMA_1_Chan;
uint8 DMA_1_TD[1];

/* DMA Configuration for DMA_1 */
DMA_1_Chan = DMA_1_DmaInitialize(DMA_1_BYTES_PER_BURST, DMA_1_REQUEST_PER_BURST, 
    HI16(DMA_1_SRC_BASE), HI16(DMA_1_DST_BASE));
DMA_1_TD[0] = CyDmaTdAllocate();
CyDmaTdSetConfiguration(DMA_1_TD[0], 1, DMA_1_TD[0], 0);
CyDmaTdSetAddress(DMA_1_TD[0], LO16((uint32)ADC_SAR_1_SAR_WRK0_PTR), LO16((uint32)Filter_1_STAGEAH_PTR)); //STAGEAH (H: High Byte): Write into the high byte (the high 8 bits) of the filter
CyDmaChSetInitialTd(DMA_1_Chan, DMA_1_TD[0]);
CyDmaChEnable(DMA_1_Chan, 1);


}

void DMA_2_Config(void)
{
    /* Variable declarations for DMA_2 */
/* Move these variable declarations to the top of the function */
uint8 DMA_2_Chan;
uint8 DMA_2_TD[1];
/* Defines for DMA_2 */
#define DMA_2_BYTES_PER_BURST 1
#define DMA_2_REQUEST_PER_BURST 1
#define DMA_2_SRC_BASE (CYDEV_PERIPH_BASE)
#define DMA_2_DST_BASE (CYDEV_PERIPH_BASE)



/* DMA Configuration for DMA_2 */
DMA_2_Chan = DMA_2_DmaInitialize(DMA_2_BYTES_PER_BURST, DMA_2_REQUEST_PER_BURST, 
    HI16(DMA_2_SRC_BASE), HI16(DMA_2_DST_BASE));
DMA_2_TD[0] = CyDmaTdAllocate();
CyDmaTdSetConfiguration(DMA_2_TD[0], 1, DMA_2_TD[0], 0);
CyDmaTdSetAddress(DMA_2_TD[0], LO16((uint32)Filter_1_HOLDAH_PTR), LO16((uint32)VDAC8_1_Data_PTR)); //HOLDAH (H: High Byte): Send data from the high byte (the high 8 bits) of the filter to the VDAC8
CyDmaChSetInitialTd(DMA_2_Chan, DMA_2_TD[0]);
CyDmaChEnable(DMA_2_Chan, 1);

}
/* [] END OF FILE */
